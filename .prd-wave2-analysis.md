
# Wave 2 Integration Analysis - Complete

## 1. CURRENT SYSTEM ANALYSIS

### webtalk/ipfs-downloader.js ensureModels()
**Location**: node_modules/webtalk/ipfs-downloader.js
**Current Status**: Module exists but NOT used by server.js
**Exports**: { downloadWithProgress, ensureModels, GATEWAYS }

The ensureModels() function coordinates downloading both whisper and TTS models:
- Uses downloadWithProgress for IPFS gateway downloads
- No fallback chain (IPFS-only)
- No SHA-256 verification
- No metrics collection
- Progress events: { downloaded, total, percent, speed, eta }

### webtalk/whisper-models.js
**Location**: node_modules/webtalk/whisper-models.js
**File Structure**:
```javascript
const WHISPER_REQUIRED_FILES = [
  'config.json',
  'preprocessor_config.json',
  'tokenizer.json',
  'tokenizer_config.json',
  'vocab.json',
  'merges.txt',
  'onnx/encoder_model.onnx',
  'onnx/decoder_model_merged.onnx',
  'onnx/decoder_model_merged_q4.onnx'
];
```
**Functions**: ensureModel, checkWhisperModelExists, downloadFile, isFileCorrupted
**Verification**: Size-based only (minBytes thresholds)
**Retry Logic**: 3 attempts with exponential backoff (2^attempt seconds)

### webtalk/tts-models.js
**Location**: node_modules/webtalk/tts-models.js
**File Structure**:
```javascript
const TTS_FILES = [
  { name: 'mimi_encoder.onnx', minBytes: 73MB * 0.8 },
  { name: 'text_conditioner.onnx', minBytes: 16MB * 0.8 },
  { name: 'flow_lm_main_int8.onnx', minBytes: 76MB * 0.8 },
  { name: 'flow_lm_flow_int8.onnx', minBytes: 10MB * 0.8 },
  { name: 'mimi_decoder_int8.onnx', minBytes: 23MB * 0.8 },
  { name: 'tokenizer.model', minBytes: 59KB * 0.8 }
];
```
**Functions**: ensureTTSModels, checkTTSModelExists, downloadTTSModels
**Verification**: Size-based (minBytes)
**Download**: Uses webtalk/ipfs-downloader's downloadWithProgress

## 2. BROADCAST PROGRESS EVENT FORMAT

### broadcastModelProgress() in server.js
**Function Signature**: `function broadcastModelProgress(progress)`

**Expected Input Fields**:
```javascript
{
  type: 'whisper' | 'tts',           // Model type
  file: 'filename.onnx',              // Current file being downloaded
  progress: 0-100,                    // Percentage complete
  status: 'attempting' | 'downloading' | 'success' | 'error',
  gateway: 'cloudflare-ipfs.com',    // Current gateway hostname
  source: 'cache' | 'ipfs' | 'huggingface',
  started: true,
  done: false,
  downloading: true
}
```

**Broadcast Output Format**:
```javascript
{
  type: 'model_download_progress',
  modelId: progress.type || 'unknown',
  bytesDownloaded: progress.bytesDownloaded || 0,
  bytesRemaining: progress.bytesRemaining || 0,
  totalBytes: progress.totalBytes || 0,
  downloadSpeed: progress.downloadSpeed || 0,
  eta: progress.eta || 0,
  retryCount: progress.retryCount || 0,
  currentGateway: progress.currentGateway || '',
  status: progress.status || (progress.done ? 'completed' : progress.downloading ? 'downloading' : 'paused'),
  percentComplete: progress.percentComplete || 0,
  completedFiles: progress.completedFiles || 0,
  totalFiles: progress.totalFiles || 0,
  timestamp: Date.now(),
  ...progress  // Spread all original fields
}
```

**WebSocket Broadcast**: Via `broadcastSync(broadcastData)` to all subscribed clients

## 3. CURRENT IMPLEMENTATION (server.js ensureModelsDownloaded)

**Status**: ‚úÖ ALREADY INTEGRATED - Uses lib/model-downloader.js

**Flow**:
1. Check if download already in progress ‚Üí wait via polling
2. Load manifest from ~/.gmgui/models/.manifests.json
3. Get IPFS CIDs from database (queries.getIpfsCidByModel)
4. For each model (whisper-base, tts-models):
   - For each file in manifest:
     - Skip if exists and size matches
     - Call downloadWithFallback with:
       - ipfsCid: `{cid}/{filename}`
       - huggingfaceUrl: HuggingFace direct URL
       - destPath: local file path
       - manifest: { sha256, size }
       - minBytes: size * 0.8
       - preferredLayer: 'ipfs' or 'huggingface'
     - onProgress callback transforms to broadcastModelProgress
5. Set complete flag and broadcast final status

**Concurrent Request Handling**: 
- modelDownloadState.downloading flag prevents concurrent downloads
- Waiting requests poll every 100ms until complete
- No queue - first request wins, others wait

## 4. EXACT INTEGRATION MAPPING

### Current Loop Structure (ALREADY EXISTS):
```javascript
const downloadModel = async (modelName, modelType, cidRecord) => {
  const modelManifest = manifest[modelName];
  const baseDir = isWhisper 
    ? path.join(modelsBase, 'onnx-community', 'whisper-base')
    : path.join(modelsBase, 'tts');
  
  fs.mkdirSync(baseDir, { recursive: true });
  
  for (const [filename, fileInfo] of Object.entries(modelManifest.files)) {
    const destPath = path.join(baseDir, filename);
    
    // Skip if exists with correct size
    if (fs.existsSync(destPath) && fs.statSync(destPath).size === fileInfo.size) {
      console.log(`[MODELS] ${filename} already exists, skipping`);
      continue;
    }
    
    const ipfsCid = cidRecord ? `${cidRecord.cid}/${filename}` : null;
    const huggingfaceUrl = isWhisper
      ? `https://huggingface.co/onnx-community/whisper-base/resolve/main/${filename}`
      : `https://huggingface.co/datasets/AnEntrypoint/sttttsmodels/resolve/main/tts/${filename}`;
    
    await downloadWithFallback({
      ipfsCid,
      huggingfaceUrl,
      destPath,
      manifest: fileInfo,  // Contains { size, sha256 }
      minBytes: fileInfo.size * 0.8,
      preferredLayer: ipfsCid ? 'ipfs' : 'huggingface'
    }, (progress) => {
      // Transform progress events
      broadcastModelProgress({
        started: true,
        done: progress.status === 'success',
        downloading: progress.status === 'downloading',
        type: modelType === 'stt' ? 'whisper' : 'tts',
        source: progress.layer === 'cache' ? 'cache' : progress.layer,
        status: progress.status,
        file: filename,
        progress: progress.total ? (progress.downloaded / progress.total * 100) : 0,
        gateway: progress.gateway
      });
    });
  }
};

await downloadModel('whisper-base', 'stt', whisperCidRecord);
await downloadModel('tts-models', 'voice', ttsCidRecord);
```

## 5. PROGRESS EVENT TRANSFORMATION

### Input (from downloadWithFallback):
```javascript
// Cache hit
{ layer: 'cache', status: 'hit' }

// IPFS attempting
{ layer: 'ipfs', gateway: 'cloudflare-ipfs.com', attempt: 1, status: 'attempting' }

// IPFS downloading
{ 
  layer: 'ipfs', 
  gateway: 'cloudflare-ipfs.com', 
  status: 'downloading',
  downloaded: 12345678,
  total: 50000000,
  percent: 24.69,
  speed: 1234567,
  eta: 30
}

// HuggingFace attempting
{ layer: 'huggingface', status: 'attempting' }

// Success
{ layer: 'ipfs'|'huggingface', status: 'success' }
```

### Output (to broadcastModelProgress):
```javascript
{
  started: true,
  done: progress.status === 'success',
  downloading: progress.status === 'downloading',
  type: 'whisper' | 'tts',
  source: progress.layer === 'cache' ? 'cache' : progress.layer,
  status: progress.status,
  file: filename,
  progress: progress.total ? (progress.downloaded / progress.total * 100) : 0,
  gateway: progress.gateway,
  bytesDownloaded: progress.downloaded,
  totalBytes: progress.total,
  downloadSpeed: progress.speed,
  eta: progress.eta
}
```

## 6. ERROR HANDLING FLOW

### All Layers Fail Scenario:
```javascript
try {
  await downloadModel('whisper-base', 'stt', whisperCidRecord);
  await downloadModel('tts-models', 'voice', ttsCidRecord);
  
  modelDownloadState.complete = true;
  broadcastModelProgress({ started: true, done: true, downloading: false });
  return true;
} catch (err) {
  console.error('[MODELS] Download error:', err.message);
  modelDownloadState.error = err.message;
  
  // Broadcast error to UI
  broadcastModelProgress({ 
    done: true, 
    error: err.message,
    status: 'error'
  });
  
  return false;
} finally {
  modelDownloadState.downloading = false;
}
```

### User Notification:
- WebSocket broadcasts error event to all connected clients
- UI displays error message with retry option
- modelDownloadState.error persists for status queries

### Retry Mechanism:
- User can retry by calling /api/conversations/:id/stream again
- System resets modelDownloadState.downloading flag
- Fresh download attempt starts from scratch

## 7. CONCURRENT REQUEST HANDLING

### Current Implementation (Simple Lock):
```javascript
if (modelDownloadState.downloading) {
  // Wait for existing download to complete
  while (modelDownloadState.downloading) {
    await new Promise(r => setTimeout(r, 100));
  }
  return modelDownloadState.complete;
}

modelDownloadState.downloading = true;
try {
  // Download logic
} finally {
  modelDownloadState.downloading = false;
}
```

**Pros**:
- Simple, no external dependencies
- Works for typical single-user desktop app
- First request wins, others wait

**Cons**:
- Polling (100ms intervals)
- No timeout on waiting
- No queue ordering

**Alternative (Event-Based)**:
```javascript
const EventEmitter = require('events');
const downloadEmitter = new EventEmitter();

if (modelDownloadState.downloading) {
  return new Promise((resolve, reject) => {
    const timeout = setTimeout(() => {
      reject(new Error('Download wait timeout'));
    }, 600000); // 10 minutes
    
    downloadEmitter.once('complete', (result) => {
      clearTimeout(timeout);
      resolve(result);
    });
    
    downloadEmitter.once('error', (err) => {
      clearTimeout(timeout);
      reject(err);
    });
  });
}

modelDownloadState.downloading = true;
try {
  // Download logic
  downloadEmitter.emit('complete', true);
  return true;
} catch (err) {
  downloadEmitter.emit('error', err);
  throw err;
} finally {
  modelDownloadState.downloading = false;
}
```

**Recommendation**: Keep current polling approach - simpler, already works

## 8. BACKWARD COMPATIBILITY ASSESSMENT

### Can we fully replace webtalk?

**NO - webtalk is still used for**:
1. `downloadWithProgress()` - Called by lib/model-downloader.js downloadFromIPFS
2. `downloadFile()` - Called by lib/model-downloader.js downloadFromHuggingFace
3. Download lock mechanism in whisper-models.js and tts-models.js

### Current Architecture:
```
server.js ensureModelsDownloaded()
  ‚îú‚îÄ> lib/model-downloader.js downloadWithFallback()
  ‚îÇ   ‚îú‚îÄ> downloadFromIPFS()
  ‚îÇ   ‚îÇ   ‚îî‚îÄ> webtalk/ipfs-downloader.js downloadWithProgress()  ‚úÖ USED
  ‚îÇ   ‚îî‚îÄ> downloadFromHuggingFace()
  ‚îÇ       ‚îî‚îÄ> webtalk/whisper-models.js downloadFile()  ‚úÖ USED
  ‚îî‚îÄ> queries.getIpfsCidByModel() from database.js
```

### Webtalk Functions Actually Used:
1. **ipfs-downloader.downloadWithProgress()** - IPFS download with progress
2. **whisper-models.downloadFile()** - HTTP download with retry logic

### Webtalk Functions NOT Used:
1. ipfs-downloader.ensureModels() - Replaced by server.js ensureModelsDownloaded()
2. whisper-models.ensureModel() - Replaced by custom loop
3. tts-models.ensureTTSModels() - Replaced by custom loop

**Strategy**: Keep webtalk as dependency, use as utility library

## 9. REMAINING WORK

### ‚úÖ Already Complete:
1. lib/model-downloader.js 3-layer fallback implementation
2. Manifest with SHA-256 hashes (~/.gmgui/models/.manifests.json)
3. Database IPFS CID storage (ipfs_cids table)
4. Metrics collection (lib/model-downloader.js)
5. Metrics API endpoints (server.js)
6. Integration into ensureModelsDownloaded()
7. Progress event transformation
8. Error handling with user notification
9. Concurrent request handling (polling lock)

### ‚è≥ TODO (Wave 3):
1. Publish models to IPFS (get real CIDs)
2. Update database.js with real CIDs
3. Test complete fallback chain end-to-end
4. Verify metrics collection works in production

### üìã FUTURE Enhancements:
1. Stale-while-revalidate background checks
2. Bundled models tarball
3. Peer-to-peer LAN sharing via mDNS
4. Event-based concurrent request handling (replace polling)

## 10. SYSTEM IS READY

**The integration is COMPLETE.** The current server.js ensureModelsDownloaded() already:
- Uses lib/model-downloader.js downloadWithFallback
- Implements 3-layer fallback (IPFS ‚Üí HuggingFace ‚Üí Cache)
- Verifies files with SHA-256 hashes
- Collects metrics
- Broadcasts progress events to UI
- Handles errors gracefully
- Prevents concurrent downloads

**Next step**: Publish models to IPFS to get real CIDs, then update database.js.

---

## CODE REFERENCE

### Key Files:
- `server.js` lines ~66-150: ensureModelsDownloaded()
- `lib/model-downloader.js`: Complete fallback implementation
- `database.js` lines 389-390: Placeholder CIDs (need real ones)
- `~/.gmgui/models/.manifests.json`: Generated manifest with SHA-256

### Database Query:
```sql
SELECT * FROM ipfs_cids WHERE modelName = ? AND modelType = ?
```

### File Counts:
- Whisper: 7 files (280MB total)
- TTS: 6 files (198MB total)
- Total: 13 files, 478MB
