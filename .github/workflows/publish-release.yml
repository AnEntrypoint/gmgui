name: Publish and Release

on:
  push:
    branches:
      - main

permissions:
  contents: write

jobs:
  publish:
    if: "!contains(github.event.head_commit.author.name, 'github-actions')"
    runs-on: ubuntu-latest
    outputs:
      version: ${{ steps.version.outputs.version }}
      published: ${{ steps.publish.outputs.published }}

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          fetch-depth: 0

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: lts/*
          registry-url: 'https://registry.npmjs.org'

      - name: Setup Bun
        uses: oven-sh/setup-bun@v1

      - name: Install dependencies
        run: npm install

      - name: Determine version to publish
        id: version
        run: |
          set -e
          
          CURRENT_VERSION=$(jq -r '.version' package.json)
          PKG_NAME=$(jq -r '.name' package.json)
          
          # Query published version from npm registry
          PUBLISHED_VERSION=$(npm view "$PKG_NAME" version 2>/dev/null || echo "0.0.0")
          
          echo "Current version in package.json: $CURRENT_VERSION"
          echo "Published version on npm: $PUBLISHED_VERSION"
          
          # Determine base version - use whichever is newer
          if [ "$CURRENT_VERSION" = "$PUBLISHED_VERSION" ]; then
            BASE_VERSION="$PUBLISHED_VERSION"
            NEEDS_BUMP=true
          else
            # Sort versions and use the higher one as base
            BASE_VERSION=$(printf '%s\n' "$CURRENT_VERSION" "$PUBLISHED_VERSION" | sort -V | tail -n1)
            if [ "$BASE_VERSION" != "$CURRENT_VERSION" ]; then
              NEEDS_BUMP=true
            else
              NEEDS_BUMP=false
            fi
          fi
          
          if [ "$NEEDS_BUMP" = "true" ]; then
            IFS='.' read -r MAJOR MINOR PATCH <<< "$BASE_VERSION"
            NEW_VERSION="$MAJOR.$MINOR.$((PATCH + 1))"
            
            # Update package.json
            jq --arg v "$NEW_VERSION" '.version = $v' package.json > package.json.tmp
            mv package.json.tmp package.json
            
            echo "version=$NEW_VERSION" >> $GITHUB_OUTPUT
            echo "bumped=true" >> $GITHUB_OUTPUT
            echo "Bumped version: $BASE_VERSION -> $NEW_VERSION"
          else
            echo "version=$CURRENT_VERSION" >> $GITHUB_OUTPUT
            echo "bumped=false" >> $GITHUB_OUTPUT
            echo "Version unchanged: $CURRENT_VERSION"
          fi

      - name: Commit version bump if needed
        if: steps.version.outputs.bumped == 'true'
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git add package.json
          git commit -m "chore: bump version to ${{ steps.version.outputs.version }}"
          git fetch origin main
          git push origin main

      - name: Publish to npm
        id: publish
        run: |
          set -e
          npm publish
          echo "published=true" >> $GITHUB_OUTPUT
          echo "Successfully published v${{ steps.version.outputs.version }} to npm"
        env:
          NODE_AUTH_TOKEN: ${{ secrets.NPM_TOKEN }}

  build-portable:
    runs-on: windows-latest
    needs: publish
    if: needs.publish.outputs.published == 'true'
    outputs:
      portable-path: ${{ steps.build.outputs.portable-path }}

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          fetch-depth: 0

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: lts/*

      - name: Setup Bun
        uses: oven-sh/setup-bun@v1

      - name: Install dependencies
        run: npm install

      - name: Download speech models from IPFS
        shell: pwsh
        timeout-minutes: 30
        run: |
          $ErrorActionPreference = "Stop"

          $modelsDir = Join-Path $env:USERPROFILE ".gmgui" "models"
          $whisperDir = Join-Path $modelsDir "onnx-community" "whisper-base"
          $whisperOnnxDir = Join-Path $whisperDir "onnx"
          $ttsDir = Join-Path $modelsDir "tts"

          New-Item -ItemType Directory -Force -Path $whisperOnnxDir | Out-Null
          New-Item -ItemType Directory -Force -Path $ttsDir | Out-Null

          # IPFS CIDs for models
          $whisperCid = "bafybeidyw252ecy4vs46bbmezrtw325gl2ymdltosmzqgx4edjsc3fbofy"
          $ttsCid = "bafybeidyw252ecy4vs46bbmezrtw325gl2ymdltosmzqgx4edjsc3fbofy"
          $tokenizerCid = "bafkreigumf3fvylzkzthrsjqshc7u3zjqtbrxpuzbpy2uywzfrsnsg6d6y"

          # Gateway prioritization (Lighthouse → Cloudflare → dweb.link)
          $gateways = @(
            "https://gateway.lighthouse.storage/ipfs/",
            "https://cloudflare-ipfs.com/ipfs/",
            "https://dweb.link/ipfs/"
          )

          function Download-WithFallback {
            param([string]$Cid, [string]$FilePath, [string]$OutputPath, [string]$FileName, [string]$HuggingFaceUrl = "")

            $maxRetries = 3
            $success = $false

            # Try IPFS gateways first (if CID provided)
            if ($Cid) {
              foreach ($gateway in $gateways) {
                if ($success) { break }

                for ($attempt = 1; $attempt -le $maxRetries; $attempt++) {
                  try {
                    $url = "$gateway$Cid/$FilePath"
                    Write-Host "  IPFS: $gateway ... $FileName"

                    $ProgressPreference = 'SilentlyContinue'
                    Invoke-WebRequest -Uri $url -OutFile $OutputPath -UseBasicParsing -TimeoutSec 30 -ErrorAction Stop

                    $size = [math]::Round((Get-Item $OutputPath).Length / 1MB, 2)
                    Write-Host "    ✓ ${size}MB"
                    $success = $true
                    break
                  } catch {
                    if ($attempt -eq $maxRetries) {
                      Remove-Item $OutputPath -ErrorAction SilentlyContinue
                    } else {
                      Start-Sleep -Seconds 1
                    }
                  }
                }
              }
            }

            # Fallback to HuggingFace if provided and IPFS failed
            if (-not $success -and $HuggingFaceUrl) {
              for ($attempt = 1; $attempt -le $maxRetries; $attempt++) {
                try {
                  Write-Host "  HuggingFace ... $FileName"

                  $ProgressPreference = 'SilentlyContinue'
                  Invoke-WebRequest -Uri $HuggingFaceUrl -OutFile $OutputPath -UseBasicParsing -TimeoutSec 60 -ErrorAction Stop

                  $size = [math]::Round((Get-Item $OutputPath).Length / 1MB, 2)
                  Write-Host "    ✓ ${size}MB"
                  $success = $true
                  break
                } catch {
                  if ($attempt -eq $maxRetries) {
                    Remove-Item $OutputPath -ErrorAction SilentlyContinue
                  } else {
                    Start-Sleep -Seconds 2
                  }
                }
              }
            }

            if (-not $success) {
              throw "Failed to download $FileName from all sources"
            }
          }

          # Whisper model files
          $whisperFiles = @(
            @{ IPFSPath = "stt/onnx-community/whisper-base/config.json";                    Name = "config.json" },
            @{ IPFSPath = "stt/onnx-community/whisper-base/tokenizer.json";                 Name = "tokenizer.json" },
            @{ IPFSPath = "stt/onnx-community/whisper-base/tokenizer_config.json";          Name = "tokenizer_config.json" },
            @{ IPFSPath = "stt/onnx-community/whisper-base/onnx/encoder_model.onnx";        Name = "encoder_model.onnx" },
            @{ IPFSPath = "stt/onnx-community/whisper-base/onnx/decoder_model_merged.onnx"; Name = "decoder_model_merged.onnx" }
          )

          # TTS model files
          $ttsFiles = @(
            @{ IPFSPath = "tts/mimi_encoder.onnx";      Name = "mimi_encoder.onnx" },
            @{ IPFSPath = "tts/flow_lm_main_int8.onnx"; Name = "flow_lm_main_int8.onnx" },
            @{ IPFSPath = "tts/mimi_decoder_int8.onnx"; Name = "mimi_decoder_int8.onnx" },
            @{ IPFSPath = "tts/text_conditioner.onnx";  Name = "text_conditioner.onnx" },
            @{ IPFSPath = "tts/flow_lm_flow_int8.onnx"; Name = "flow_lm_flow_int8.onnx" }
          )

          $hfWhisperBase = "https://huggingface.co/onnx-community/whisper-base/resolve/main"
          $hfTtsBase = "https://huggingface.co/datasets/AnEntrypoint/sttttsmodels/resolve/main/tts"

          Write-Host "Downloading Whisper model files..."
          foreach ($file in $whisperFiles) {
            $output = if ($file.IPFSPath.Contains("/onnx/")) {
              Join-Path $whisperOnnxDir (Split-Path -Leaf $file.IPFSPath)
            } else {
              Join-Path $whisperDir $file.Name
            }
            $hfUrl = "$hfWhisperBase/$($file.Name)"
            Download-WithFallback -Cid $whisperCid -FilePath $file.IPFSPath -OutputPath $output -FileName $file.Name -HuggingFaceUrl $hfUrl
          }

          Write-Host "Downloading TTS model files..."
          foreach ($file in $ttsFiles) {
            $output = Join-Path $ttsDir $file.Name
            $hfUrl = "$hfTtsBase/$($file.Name)"
            Download-WithFallback -Cid $ttsCid -FilePath $file.IPFSPath -OutputPath $output -FileName $file.Name -HuggingFaceUrl $hfUrl
          }

          Write-Host "Downloading tokenizer..."
          $output = Join-Path $ttsDir "tokenizer.model"
          $hfUrl = "$hfTtsBase/tokenizer.model"
          Download-WithFallback -Cid $tokenizerCid -FilePath "" -OutputPath $output -FileName "tokenizer.model" -HuggingFaceUrl $hfUrl

          $totalSize = 0
          Get-ChildItem -Path $modelsDir -Recurse -File | ForEach-Object { $totalSize += $_.Length }
          $totalMB = [math]::Round($totalSize / 1MB, 1)
          Write-Host "All models downloaded: ${totalMB}MB total"

      - name: Wait for model downloads to complete
        shell: pwsh
        run: |
          $modelsDir = Join-Path $env:USERPROFILE ".gmgui" "models"
          $timeout = 0
          $maxWait = 120

          Write-Host "Waiting for models to be available..."
          while ($timeout -lt $maxWait) {
            if (Test-Path $modelsDir) {
              $fileCount = @(Get-ChildItem -Path $modelsDir -Recurse -File).Count
              if ($fileCount -gt 0) {
                $totalSize = 0
                Get-ChildItem -Path $modelsDir -Recurse -File | ForEach-Object { $totalSize += $_.Length }
                $totalMB = [math]::Round($totalSize / 1MB, 1)
                Write-Host "✓ Models ready: $fileCount files, ${totalMB}MB"
                exit 0
              }
            }
            Start-Sleep -Seconds 2
            $timeout += 2
          }

          Write-Host "⚠ Models not fully ready after ${maxWait}s, proceeding anyway (models will be bundled if available)"

      - name: Build portable executable
        id: build
        shell: pwsh
        run: |
          $ErrorActionPreference = "Stop"

          Write-Host "Starting portable build..."
          $modelsDir = Join-Path $env:USERPROFILE ".gmgui" "models"
          Write-Host "Models source directory: $modelsDir"

          $env:MODELS_SOURCE_DIR = $modelsDir
          $env:NO_BUNDLE_MODELS = 'false'
          $env:GITHUB_OUTPUT = $env:GITHUB_OUTPUT  # Ensure build-portable.js can write outputs
          node build-portable.js

      - name: Verify models bundled in portable
        shell: pwsh
        run: |
          $buildPath = "${{ steps.build.outputs.portable-path }}"
          $modelsDir = Join-Path $buildPath "models"

          if (Test-Path $modelsDir) {
            $fileCount = @(Get-ChildItem -Path $modelsDir -Recurse -File).Count
            $totalSize = 0
            Get-ChildItem -Path $modelsDir -Recurse -File | ForEach-Object { $totalSize += $_.Length }
            $totalMB = [math]::Round($totalSize / 1MB, 1)
            Write-Host "✓ Models bundled: $fileCount files, ${totalMB}MB"
          } else {
            Write-Host "⚠ WARNING: No models directory in build output"
            Write-Host "  Build path: $buildPath"
            Write-Host "  Contents:"
            Get-ChildItem -Path $buildPath -Force | ForEach-Object { Write-Host "    $($_.Name) $(if($_.PSIsContainer) {'(dir)'} else {'(' + [math]::Round($_.Length/1MB, 1) + 'MB)'})" }
          }

      - name: Create zip archive
        id: archive
        shell: pwsh
        run: |
          $ErrorActionPreference = "Stop"

          $src = "${{ steps.build.outputs.portable-path }}"
          $zipName = "agentgui-v${{ needs.publish.outputs.version }}-windows-portable.zip"
          $dest = Join-Path "${{ github.workspace }}" $zipName

          if (Test-Path $src) {
            Write-Host "Creating zip from: $src"
            # Zip the contents of the build directory (including subdirectories)
            Get-ChildItem -Path $src -Exclude "agentgui-*.zip" | Compress-Archive -DestinationPath $dest -Force
            Write-Host "Archive created: $dest"

            $size = [math]::Round((Get-Item $dest).Length / 1MB, 1)
            Write-Host "Archive size: ${size}MB"
            Add-Content -Path $env:GITHUB_OUTPUT -Value "archive=$dest"
          } else {
            Write-Host "ERROR: Build directory not found: $src"
            exit 1
          }

      - name: Upload portable archive as artifact
        uses: actions/upload-artifact@v4
        with:
          name: agentgui-windows-portable
          path: agentgui-v${{ needs.publish.outputs.version }}-windows-portable.zip
          retention-days: 1

  create-release:
    runs-on: ubuntu-latest
    needs: [publish, build-portable]
    if: needs.publish.outputs.published == 'true'

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Download build artifacts
        uses: actions/download-artifact@v4
        with:
          path: release-artifacts
        continue-on-error: true

      - name: Get latest commit info
        id: commit
        run: |
          COMMIT_HASH=$(git rev-parse --short HEAD)
          COMMIT_MSG=$(git log -1 --pretty=%B)
          echo "hash=$COMMIT_HASH" >> $GITHUB_OUTPUT
          echo "msg<<EOF" >> $GITHUB_OUTPUT
          echo "$COMMIT_MSG" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

      - name: Create GitHub Release
        uses: softprops/action-gh-release@v2
        with:
          tag_name: v${{ needs.publish.outputs.version }}
          name: AgentGUI v${{ needs.publish.outputs.version }}
          body: |
            ## AgentGUI v${{ needs.publish.outputs.version }}

            **Latest commit**: ${{ steps.commit.outputs.hash }}
            ${{ steps.commit.outputs.msg }}

            Install with:
            ```bash
            bunx agentgui@latest
            npm install -g agentgui
            npx agentgui
            ```

            **Web interface**: http://localhost:3000/gm/

            **Windows Portable Build**:
            - Self-contained executable (no installation required)
            - Includes ~470MB of bundled speech models
            - Models distributed via IPFS (decentralized)
            - Unzip and run `agentgui.exe`

            **Notes**:
            - Data stored in `~/.gmgui/` folder
            - Requirements: Node.js 18+ (for npm/bun installs), or standalone exe (no requirements)
          draft: false
          prerelease: false
          files: |
            release-artifacts/**/*.zip
